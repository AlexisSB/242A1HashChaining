--2016 EXAM--
1. Debugging
a. 
A bug occurs when the program departs from the program model. If the program isn't doing what it's supposed to do, it's a bug.
b. 
Debugging is the process of identifying a problem, identifying the cause of the problem, and fixing it.
Scientific method for debugging: use repeatable experiments to gather data about the source of the problem, form a hypothesis about what the core problem is, create another experiment to prove/refute the hypothesis. Once the error is found, fix it. Then, test again to ensure the problem is fixed.
c. 
How long does debugging take? McConnell says that 50% of development time is spent debugging; 90% of that is spent finding the bugs, 10% fixing.
d. 
How can the compiler help find bugs before they happen?
The compiler can report errors and warnings during the compilation process, meaning that bugs can be caught without needing to run the program. For best results, use compiler flags to set all warning levels as high as possible, and ensure that everyone on the project is using the same flags. Fix any errors that the compiler reports. Treat compiler warnings as errors, and fix them at the source (do not just make the warning messages go away).
e. 
How/Why can the compiler produce incorrect errors?
Errors may cascade down from places other than those reported by the compiler. In these cases, error messages and line numbers can be misleading, so it may be necessary to explore possible causes of the error more thoroughly.
f. 
3 places in code base where you are likely to find a bug:
-loops (recursive and iterative)
-recently changed/added code
-code that has previously caused problems
-heavily commented code - if it was awkward to write, and needs lots of explanation, there might be something wrong with it.
g. 
3 places in code base where you are unlikely to find a bug:
-code that has been thoroughly tested
-simple, clear statements (e.g. assignments)
-short, elegant blocks of code
h. 
When fixing bugs, you should test before and after to ensure that the source of the error has been correctly identified and fixed. If you try to fix multiple bugs at once, it may be harder to test this accurately. Changes made to fix one bug might cause more bugs, change existing bugs, or mask the problems associated with another bug.
EXTRA
Use version control to keep backups before you change the code, in case you make it worse.
Make sure you understand the problem before trying to fix it, by testing before and after. Don't guess what the problem is, or just fix the symptoms. Even if the problems disappear, the bug might still be present, ready to cause more problems later on.
Good code is easier to debug than bad code. Code should be simple, readable, and easy to follow/diagnose.

2. The Project
a. 
"Plan to throw one away; you will, anyhow". Brooks is talking about the fact that many projects are barely usable in their first iterations, and that it is usually necessary to throw away the first version and start again. The problems are likely to be too numerous and fundamental to simply shift the software into a better state. This happens because of imperfect knowledge on the part of the programmers (about how to do things, and what problems may arise in the future), and shifting expectations from the clients.
Our project required lots of cutting of features and changing of implementation over hte course of the year, as we gradually figured out how much time each thing would *really* take. In particular, this meant restructuring large parts of the program at several points.
b. 
The second-system effect occurs when the programmer moves to the second iteration of a piece of software. Often the first iteration is built with careful design and restraint, but the builder comes up with ideas for extra features and embellishments. When it comes time to make the next version, the builder may end up over-designing, adding unnecessary/cumbersome features, trying to perfect features from the first design that could just as well be cut.
To avoid this on a hypothetical redesign of our project, it would be important to carefully re-examine the fundamental purpose of the product, create a reasonable plan before starting, plan to throw away an iteration or two, and to avoid the temptation to try to cram in extraneous features. 
c.
There don;t seem to be any notes about communication?
di. 
Elegance of source code: Use descriptive names to variables, functions, etc.
Each function should have a single, clear purpose. Make agreements with team members about conventions, so that all of the code is in the same style.
dii. 
Elegance of UI: Simplicity - have as few elements as possible. Try to reuse common elements of UIs, so that users will have a more intuitive, familiar experience.

3. The Future (driverless cars)
There is a lot to think about with driverless cars. Decisions made in building the software are extremely important, since lives are at stake.
For a start, error testing must be extremely rigorous. The developers should pay close attention to the way the software responds to all input the sensors could be expected to come across on the road. They should also look closely at how it responds to unexpected, anomalous input, and what happens if different parts of the program fail.
There are also big ethical questions surrounding the kinds of decisions the driverless car may have to make. Whose safety should be prioritised when a crash becomes unavoidable? This is literally a problem used in philosophy to illustrate ethical dilemmas (the trolley problem). Consultation with an ethical committee, at the very least, would be required when designing this kind of AI.

4. Memory (lol, no way)

5. Project Planning and Management
a.
Why is software management hard?
Software projects are usually unique, such that prior experience may be unhelpful or misleading. It is often unclear how long a project will take, and it can be difficult to monitor the progress of a project.
b.
A risk is anything with the potential to pose setbacks to the project. This includes staff turnover, availability and usability of required hardware, bad deadline estimation, changes in requirements/technology, etc.
A project plan should include a risk analysis that lays out all the possible risks, the consequences of each risk, the probability of that risk occurring, a comparison of the costs of avoiding / fixing the consequences, and a contingency plan for the consequences.
c.
Requirements are the features requested by the client. A client may change their mind about what the product requires, for a lot of different reasons. Advances in technology, changes in the market, and changes in the client's situation may cause requirements to change. To combat this, we should try to factor in possible requirement changes into our risk analysis. Regular communication with the client will also help requirement changes to be acknowledged as soon as possible, so that the development team can pivot quickly and appropriately.
d.
There are no standards for measuring progress in software development, because the product is intangible. As such, it is very difficult to estimate how it will take to reach a milestone. To help scheduling, we can try to divide the project into parts, identify dependencies between them, and estimate how long each part will take (allowing time for unexpected issues; always assume problems will occur).
e.
Source Lines of Code (SLOC) is basically a measure of how much code a program will need to meet all the product requirements. It is a measure of the number of executable statements in the software (and therefore the amount of effort the project will require). The problem is that is hard to estimate the SLOC for any project before work has begun. Additionally, it is dependent on the particular implementation/style used by the programmer - two versions of the same project might end up with different SLOC counts. Additionally, actual coding only accounts for a fraction of the overall time spent on a project (planning, training and testing each take a signficant amount of time).
UNFINISHED

6. Testing, Development, and Integration
b.
Unit Testing: 
Break the program down into small, testable units (e.g. look at individual functions), and design tests for each of these units. This ensures each individual part of the program works independently. This also means that, when a piece of code is changed, the corresponding test can be rerun to make sure it still works as intended (you don't have to try to test it by running a diagnosis on the whole program). The units should also be tested together eventually, to make sure they work in conjuction with each other.
c.
Test-Driven Development: a method of development. Before making a change or adding a feature, write a test for it (which should fail; otherwise the test is bad, or you don't need to make the change). Then make the change, and run the test to make sure it works. This means that everything is immediately tested once implemented. It also helps guide development - you define the requirements with the test, and then work minimally to fulfill those requirements.
d.
Continuous Integration: a method for working with distributed version control. All working copies of the project are merged regularly. This is done to avoid problems associated with integration conflicts (collisions between the changes of multiple developers). The longer a working copy remains checked out, the more it may diverge from the archived code.

7. Version Control and Documentation
a.
Version control is a mechanism for storing and organising backups of project files, keeping records of changes made to these files, and allowing edits to be made to the files by multiple developers concurrently.
b.
This means that anyone can see who is responsible for each part of the code. If someone has a question about part of the code, or about a change that was made, they can see who was responsible and ask them directly.
c. 
Two ways to deal with problems related to concurrent editing of a file:
-
-
d. 
3 benefits of a distributed version control system:
-allows a team to work on a project from around the world
-developers can work offline
-developers work with their own private copies, allowing them to experiment privately
-additional security: each developer's local copy serves as an extra backup
e.
What items should you keep under version control? ALL OF THEM! Source code, documentation, licenses, design docs, prototypes. Everything related to the project.
f.
Not sure, can't find slides.
g.
You could check the code itself. There may be comments that clarify the intent of the code, and the code itself will hopefully be readable. Otherwise, check the version control logs to see who is responsible for the code in question, and email them.

--2015 EXAM--
2. Profiling, Coverage and Reading
Kinda seems like profiling wasn't really addressed?
Summary about coverage: test coverage measures the amount of code exercised by tests. Class coverage = at least one test case for each class, which can tell whether the class is in a consistent state. Method coverage = each method is called in at least one test, check if the method behaves appropriately. Statement coverage = each statement is executed at least once by a test. Branch coverage = each possible conditional branch should be followed at least once by a test.

3.
a.
Version control is a mechanism for storing backups of files related to a project, keeping records of changes to those files, and allowing the files to be edited by multiple developers concurrently.
b.
Version control provides a robust backup system; if files are lost in hardware failures there are backups; if the project is broken by an edit, you can rollback to a previous version. Version control allows multiple developers to work on the same files at the same time. It provides automatic logs of all changes to the project (who made the changes and when).
c.
Best practice:
-always use version control. ALWAYS.
-version control everything related to the project: code, documentation, prototypes, management material.
-always checkout before making changes, to minimise merge conflicts.
-check-in regularly, to minimise problems associated with integration.
-label each release with a version number, so it's easier to look back at (theoretically) stable builds.
-test all code before committing; don't push bugs into the archive, where possible
di.
If two programmers edit the same file, one of their edits might be overwritten by the other (lost update problem).
dii.
Lock management can help - when someone checks-out a file, no one else can check it out until it's checked in again (they can get a read only copy though).
For files being edited concurrently, merges need to be done manually (i.e. figure out which changes should be kept, resolve it all in one file and push).
diii.
Lock tools, tools that help with merging.
e.
Logs show who is working on what, as well as exactly what changes they make and when. Monitoring this, and the overall number of merges, gives some idea of how the project is progressing??
f.
A file may have a large number of pulls/pushes associated with it if it has required a lot of tweaking/debugging. This may indicate that the code is a problem point for the project.
g.
If updates are not checked in, other programmers will be working with outdated code. This could cause them to make inappropriate/unnecessary updates. It could also cause integration problems when merging down the line.
If an untested file is checked in, other programmers may end up working with faulty code.

4. Coupling and Documentation
a.
Coupling is the degree of interdependence between modules in a program. A good program has low coupling, so that each module works independently and interfaces with other modules. This means that any one module can be changed/tested without needing to touch any other modules.
b.
c.
Coupling hinders maintenance. If one thing doesn't work right in a high coupling program, many parts of the program may need to be changed.
d.
External documentation exists outside the source code. It includes descriptions of important parts of the code, broad overviews of the structure of the code, and guides on how to use the software. External documentation is for users (i.e. people who want to be able to use, adapt and maintain the program).
e.
Internal documentation exists in the source code (comments). Comments explain the intent of the code and/or what the code does. Internal documentation is for developers.
f.
Internal documentation can help or hinder maintenance, depending on the quality of the comments. The comments should clarify the intent of each piece of code, rather than just describing what it does. When the comments describe the code, someone could change the code without changing the comments, in which case the internal documentation is misleading. Where comments clarify the intent of code, however, they provide helpful hints about how the program fits together.

5. Static Verification

6. Cost estimation, prototyping, and scripting
a. 
3 reasons our estimates may be wrong, and a way of dealing with it:
-at the start of a project, there may be some uncertainty about the problems that the project will involve. Solve this with thorough discussions about the project with people from a range of perspectives (other POVs might see different problems)
-imperfect knowledge, people might not know the appropriate solutions to a problem. Solve this by planning for delays, and involve lots of people, smart in different areas, in cost estimation. 
-optimism: we tend to not think about all the things that could co wrong. Solve this with a healthy dose of pessimism. Also, help estimates by breaking the project into smaller parts, and estimate each part.
b.
Things to estimate:
Size (how big the program will be; SLOC)
Effort (how many work days it will take)
Time (how many calendar days it will take)
Cost (financial cost)
Defects (how many bugs will need to be fixed)
c.
Cone of uncertainty: our cost estimations are very approximate at first, since we don't have much information about the project. As the project moves forward, we get more information, and we can make better estimates.
To make decent estimates early on, break the project down into smaller pieces whose costs can be estimated more easily/accurately. It also helps to present costs as a distribution rather than a single number, since this is more likely to capture more of the truth.
d.
Boehm's spiral model is a model for planning software development and evaluating risks. The model consists of cycles: in each cycle, you first determine your objectives, then identify and resolve risks (resulting in a prototype: objectives + plan of action), then develop/test/release, then plan for the next iteration (after which the cycle begins from the start).
e.
Prototyping reduces the risk of changing requirements / bad planning - if the developers work hard on something, but it turns out to not quite be what was intended, that work is wasted.
Prototyping: gather requirements, make a quick design, build a cheap prototype. Evaluate the prototype (with team/customer), and go back to the drawing board if it's not right. This makes sure everyone is on the same page - communication!
f.
Prototype is not a product, it's just supposed to look like one. A prototype isn't the same as an early version of the project, because it probably won't have any of the fundamental groundwork (e.g. data structures etc) that the actual project requires. It may even be written in a different language.
g.
What makes a good prototyping language?
-flexible, GUI-focused, high level

7. Reuse, reverse engineering, and internationalisation
a.
Advantages of using third-party code:
-code is already tested, verified to work
-reduce effort for programmers, since the code is already written
-reduce time until finish, since the code is already written
b.
Disadvantages of using third-party code:
-the code may not work as well as advertised, meaning that testing is still required
-the code may require significant adaptation to fit into your project
-the code may be poorly maintained, which becomes your problem
-the code may be too specific to the original project to be really reusable
c.
Reuse via text editor: copying source code directly into your project from somewhere else, and adapting it where necessary. You risk duplicating bugs, and it still requires adaptation, which kinda sucks.
d.
Compare/contrast re-engineering and reuse.

--HOW COMPLEX SYSTEMS FAIL--
System: an entity with interdependent parts (changing one part affects other parts). A system is more than the sum of its parts.
Complex System: a system that we can't feasibly conceptualise entirely at once, such that your mental model of the system has to be an approximation.
Complex systems are intrinsically hazardous, because we can't be fully sure that they work in every case. We must expect and prepare for errors.
A single failure isn't enough for catastrophe - combinations of failures are the problem. These are also the problems that are hardest to predict (problems that emerge from interactions).
A complex system that works is invariably found to have evolved from a simple system that works.

--COUPLING / COHESION--
Coupling is the degree of interdependence between software modules.
A good system has low coupling (modules should not be dependent on other modules).
Low coupling = independent

Cohesion is the degree to which the elements within a module belong together.
A good system has high cohesion (modules should not do lots of different things).
High cohesion = focused

--McConnell's Checklist--
 Routines - name should be descriptive
          - should perform ONE well-defined task
          - subparts separated out into different routines
          - obvious clear interface
 Data - variable names should be descriptive (even loop variables)
      - variables should be only used for one purpose
      - use enumerated types instead of flags
      - use named constants instead of magic numbers (for clarity)
 Organisation - add extra variables when it would make the program clearer
	      - data structures should *reduce* complexity
	      - complex data should have special access routines
	      - don't comment tricky code; rewrite it!
              - comments clarify the intent of the code, not explain it
 Control - normal control path should be clear
	 - make boolean operations readable

--Scripting languages -> see Wikipedia?--

